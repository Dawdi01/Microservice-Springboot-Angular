package com.example.gestionmatch.service;import com.example.gestionmatch.model.*;import com.example.gestionmatch.repository.EquipeRepository;import com.example.gestionmatch.repository.MatchRepository;import com.example.gestionmatch.repository.TerrainRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.text.SimpleDateFormat;import java.util.*;@Servicepublic class MatchService {    private final MatchRepository matchRepository;    private final EquipeRepository equipeRepository;    private final TerrainRepository terrainRepository;    public MatchService(MatchRepository matchRepository,                        EquipeRepository equipeRepository,                        TerrainRepository terrainRepository) {        this.matchRepository = matchRepository;        this.equipeRepository = equipeRepository;        this.terrainRepository = terrainRepository;    }    public Match createMatch(Match match) {        try {            return matchRepository.save(match);  // Sauvegarde du match et retour du match sauvegardé        } catch (Exception e) {            throw new RuntimeException("Erreur lors de la création du match : " + e.getMessage());        }    }    public List<Match> getAllMatches() {        return matchRepository.findAll();    }    public Optional<Match> getMatchById(String id) {        return matchRepository.findById(id);    }    public Match updateMatch(String id, Match matchDetails) {        Match match = matchRepository.findById(id)                .orElseThrow(() -> new RuntimeException("Match non trouvé"));        if (match.isMatchJoue() && match.getScoreEquipe1() != null && match.getScoreEquipe2() != null) {            throw new IllegalStateException("Impossible de modifier un match déjà joué avec scores renseignés.");        }        match.setDate(matchDetails.getDate());        match.setStartDate(matchDetails.getStartDate());        match.setEndDate(matchDetails.getEndDate());        match.setType(matchDetails.getType());        match.setIdEquipe1(matchDetails.getIdEquipe1());        match.setIdEquipe2(matchDetails.getIdEquipe2());        match.setIdTerrain(matchDetails.getIdTerrain());        match.setScoreEquipe1(matchDetails.getScoreEquipe1());        match.setScoreEquipe2(matchDetails.getScoreEquipe2());        match.setCartonsJaunesEquipe1(matchDetails.getCartonsJaunesEquipe1());        match.setCartonsRougesEquipe1(matchDetails.getCartonsRougesEquipe1());        match.setCartonsJaunesEquipe2(matchDetails.getCartonsJaunesEquipe2());        match.setCartonsRougesEquipe2(matchDetails.getCartonsRougesEquipe2());        match.setFautesEquipe1(matchDetails.getFautesEquipe1());        match.setFautesEquipe2(matchDetails.getFautesEquipe2());        match.setMatchJoue(matchDetails.isMatchJoue());        return matchRepository.save(match);    }    public boolean deleteMatch(String id) {        if (matchRepository.existsById(id)) {            matchRepository.deleteById(id);            return true;        } else {            return false;        }    }    public Match matchDetails(Match matchDetails) {        Equipe equipe1 = equipeRepository.findById(matchDetails.getIdEquipe1())                .orElseThrow(() -> new RuntimeException("Équipe 1 non trouvée"));        Equipe equipe2 = equipeRepository.findById(matchDetails.getIdEquipe2())                .orElseThrow(() -> new RuntimeException("Équipe 2 non trouvée"));        Terrain terrain = terrainRepository.findById(matchDetails.getIdTerrain())                .orElseThrow(() -> new RuntimeException("Terrain non trouvé"));        matchDetails.setEquipe1(equipe1);        matchDetails.setEquipe2(equipe2);        matchDetails.setTerrain(terrain);        return matchDetails;    }    public Match affecterEquipesAMatch(String matchId, String equipeId1, String equipeId2) {        // Récupérer le match        Match match = matchRepository.findById(matchId)                .orElseThrow(() -> new RuntimeException("Match non trouvé"));        // Récupérer les équipes        Equipe equipe1 = equipeRepository.findById(equipeId1)                .orElseThrow(() -> new RuntimeException("Équipe 1 non trouvée"));        Equipe equipe2 = equipeRepository.findById(equipeId2)                .orElseThrow(() -> new RuntimeException("Équipe 2 non trouvée"));        match.setIdEquipe1(equipeId1);        match.setIdEquipe2(equipeId2);        // Affecter les équipes au match        match.setEquipe1(equipe1);        match.setEquipe2(equipe2);        // Sauvegarder le match mis à jour        matchRepository.save(match);        return match;    }    public Match desaffecterUneEquipeDuMatch(String matchId, String equipeId) {        // Récupérer le match        Match match = matchRepository.findById(matchId)                .orElseThrow(() -> new RuntimeException("Match non trouvé"));        // Comparaison des IDs directement        if (match.getIdEquipe1() != null && match.getIdEquipe1().equals(equipeId)) {            match.setIdEquipe1(null);        } else if (match.getIdEquipe2() != null && match.getIdEquipe2().equals(equipeId)) {            match.setIdEquipe2(null);        } else {            throw new RuntimeException("L'équipe spécifiée n'est pas affectée à ce match");        }        // Sauvegarde        return matchRepository.save(match);    }    public Match affecterScores(String id, int scoreEquipe1, int scoreEquipe2) {        return matchRepository.findById(id)                .map(match -> {                    match.setScoreEquipe1(scoreEquipe1);  // Mise à jour des scores                    match.setScoreEquipe2(scoreEquipe2);  // Mise à jour des scores                    return matchRepository.save(match);                })                .orElseThrow(() -> new RuntimeException("Match non trouvé"));    }    public Match affecterTerrain(String matchId, String terrainId) {        Match match = matchRepository.findById(matchId)                .orElseThrow(() -> new RuntimeException("Match non trouvé"));        // Vérifie que le terrain existe        Terrain terrain = terrainRepository.findById(terrainId)                .orElseThrow(() -> new RuntimeException("Terrain non trouvé"));        // Affecte l'ID        match.setIdTerrain(terrainId);        // Enrichit l'objet transient pour le retour        match.setTerrain(terrain);        return matchRepository.save(match);    }    public Match affecterDateAuMatch(String matchId, Date nouvelleDate) {        Match match = matchRepository.findById(matchId)                .orElseThrow(() -> new RuntimeException("Match non trouvé"));        //match.setDate(nouvelleDate);        return matchRepository.save(match);    }    public Map<String, Map<String, Integer>> calculerStatistiquesParEquipe() {        List<Match> matchs = matchRepository.findAll();        Map<String, Map<String, Integer>> statsParEquipe = new HashMap<>();        for (Match match : matchs) {            // Équipe 1            String idEquipe1 = match.getIdEquipe1();            statsParEquipe.putIfAbsent(idEquipe1, initStatsMap());            Map<String, Integer> stats1 = statsParEquipe.get(idEquipe1);            stats1.put("score", stats1.get("score") + getSafeValue(match.getScoreEquipe1()));            stats1.put("cartonsJaunes", stats1.get("cartonsJaunes") + getSafeValue(match.getCartonsJaunesEquipe1()));            stats1.put("cartonsRouges", stats1.get("cartonsRouges") + getSafeValue(match.getCartonsRougesEquipe1()));            stats1.put("fautes", stats1.get("fautes") + getSafeValue(match.getFautesEquipe1()));            // Équipe 2            String idEquipe2 = match.getIdEquipe2();            statsParEquipe.putIfAbsent(idEquipe2, initStatsMap());            Map<String, Integer> stats2 = statsParEquipe.get(idEquipe2);            stats2.put("score", stats2.get("score") + getSafeValue(match.getScoreEquipe2()));            stats2.put("cartonsJaunes", stats2.get("cartonsJaunes") + getSafeValue(match.getCartonsJaunesEquipe2()));            stats2.put("cartonsRouges", stats2.get("cartonsRouges") + getSafeValue(match.getCartonsRougesEquipe2()));            stats2.put("fautes", stats2.get("fautes") + getSafeValue(match.getFautesEquipe2()));        }        return statsParEquipe;    }    public Map<String, Map<String, Integer>> calculerStatistiquesParEquipeEtDates(String dateD, String dateF) {        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");        Date dateDeb = null;        Date dateFin = null;        try {            dateDeb = format.parse(dateD);            System.out.println("Converted Start Date: " + dateDeb);        } catch (Exception e) {            System.out.println("Erreur de conversion dateD: " + dateD);            e.printStackTrace();        }        try {            dateFin = format.parse(dateF);            System.out.println("Converted End Date: " + dateFin);        } catch (Exception e) {            System.out.println("Erreur de conversion dateF: " + dateF);            e.printStackTrace();        }        if (dateDeb == null || dateFin == null) {            throw new IllegalArgumentException("Les dates fournies ne sont pas valides : " + dateD + " / " + dateF);        }        System.out.println(dateDeb + "............." + dateFin);        List<Match> matchs = matchRepository.findByDateBetween(dateDeb, dateFin);        Map<String, Map<String, Integer>> statsParEquipe = new HashMap<>();        for (Match match : matchs) {            // Équipe 1            String idEquipe1 = match.getIdEquipe1();            statsParEquipe.putIfAbsent(idEquipe1, initStatsMap());            Map<String, Integer> stats1 = statsParEquipe.get(idEquipe1);            stats1.put("score", stats1.get("score") + getSafeValue(match.getScoreEquipe1()));            stats1.put("cartonsJaunes", stats1.get("cartonsJaunes") + getSafeValue(match.getCartonsJaunesEquipe1()));            stats1.put("cartonsRouges", stats1.get("cartonsRouges") + getSafeValue(match.getCartonsRougesEquipe1()));            // Équipe 2            String idEquipe2 = match.getIdEquipe2();            statsParEquipe.putIfAbsent(idEquipe2, initStatsMap());            Map<String, Integer> stats2 = statsParEquipe.get(idEquipe2);            stats2.put("score", stats2.get("score") + getSafeValue(match.getScoreEquipe2()));            stats2.put("cartonsJaunes", stats2.get("cartonsJaunes") + getSafeValue(match.getCartonsJaunesEquipe2()));            stats2.put("cartonsRouges", stats2.get("cartonsRouges") + getSafeValue(match.getCartonsRougesEquipe2()));        }        return statsParEquipe;    }    private Map<String, Integer> initStatsMap() {        Map<String, Integer> map = new HashMap<>();        map.put("score", 0);        map.put("cartonsJaunes", 0);        map.put("cartonsRouges", 0);        return map;    }    private int getSafeValue(Integer value) {        return value != null ? value : 0;    }}